<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ubuntu (2023811)</title>
    <url>/2023/08/22/Ubuntu%20(2023811)/</url>
    <content><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h5 id="1-chmod"><a href="#1-chmod" class="headerlink" title="1.chmod"></a>1.chmod</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x clash    // 给clash增加权限</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>SQL常用命令</title>
    <url>/2023/06/22/SQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><a name="cKqKF"></a></p>
<h3 id="一）insert"><a href="#一）insert" class="headerlink" title="(一）insert"></a>(一）insert</h3><p><a name="Chmu3"></a></p>
<h4 id="1-全部字段插入"><a href="#1-全部字段插入" class="headerlink" title="1.全部字段插入"></a>1.全部字段插入</h4><p>注意：添加数据的顺序必须和表结构一致<br />存在一个表person ，字段有 id,name,sex,dep,bir</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span> ( <span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;开发部&#x27;</span>,<span class="string">&#x27;2019-07-17&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><a name="ae3i5"></a></p>
<h4 id="2-指定字段插入"><a href="#2-指定字段插入" class="headerlink" title="2.指定字段插入"></a>2.指定字段插入</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person(name,sex) <span class="keyword">values</span> (<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person(name,sex,bir) <span class="keyword">values</span> (<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,NOW()) </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> NOW()表示当前时间（yyyy<span class="operator">-</span>mm<span class="operator">-</span>dd hh:mm:ss），SYSDATA()也可以</span><br></pre></td></tr></table></figure>
<p><a name="YdGQQ"></a></p>
<h3 id="二）update"><a href="#二）update" class="headerlink" title="(二）update"></a>(二）update</h3><p>注意：修改语句通常指定条件，否则会对所以数据进行修改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> person <span class="keyword">set</span> dep<span class="operator">=</span><span class="string">&#x27;开发部&#x27;</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;李四&#x27;</span></span><br><span class="line"><span class="keyword">update</span> person <span class="keyword">set</span> dep<span class="operator">=</span><span class="string">&#x27;开发部&#x27;</span>，sex<span class="operator">=</span>&quot;女&quot; <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;李四&#x27;</span></span><br></pre></td></tr></table></figure>
<p><a name="j5Azj"></a></p>
<h3 id="三）delete"><a href="#三）delete" class="headerlink" title="(三）delete"></a>(三）delete</h3><p>注意：删除语句通常指定条件，否则会对所以数据进行删除</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> person  <span class="comment">// 全删</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> person where id=<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><a name="bM1oD"></a></p>
<h3 id="四）select"><a href="#四）select" class="headerlink" title="(四）select"></a>(四）select</h3><p><a name="QAbsJ"></a></p>
<h4 id="1）select-子语句"><a href="#1）select-子语句" class="headerlink" title="(1）select 子语句"></a>(1）select 子语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from person</span><br><span class="line">select name ,dep from person</span><br><span class="line">select name n,dep d from person //n和p是别名 </span><br></pre></td></tr></table></figure>
<p><a name="dTrGj"></a></p>
<h4 id="2）from子语句"><a href="#2）from子语句" class="headerlink" title="(2）from子语句"></a>(2）from子语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> person;</span><br><span class="line"><span class="keyword">select</span> person.id,perons.name <span class="keyword">from</span> person</span><br><span class="line"><span class="keyword">select</span> t.id,person.name <span class="keyword">from</span> person t;</span><br></pre></td></tr></table></figure>
<p><a name="z9ToZ"></a></p>
<h4 id="3-where-子语句"><a href="#3-where-子语句" class="headerlink" title="(3) where 子语句"></a>(3) where 子语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 逻辑运算符 <span class="operator">&gt;</span>,<span class="operator">&lt;</span> ,...,<span class="keyword">and</span>,<span class="keyword">or</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> job <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">20</span> <span class="keyword">and</span> age<span class="operator">&lt;</span><span class="number">25</span> <span class="keyword">and</span> sex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="operator">/</span><span class="operator">/</span> <span class="keyword">and</span> <span class="keyword">or</span> <span class="keyword">not</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 数字区间运算符</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> job <span class="keyword">where</span> age <span class="keyword">between</span> <span class="number">18</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> job <span class="keyword">where</span> age <span class="keyword">not</span> <span class="keyword">between</span> <span class="number">18</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 集合运算符</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> job <span class="keyword">where</span> position <span class="keyword">in</span> (<span class="string">&#x27;美工&#x27;</span>,<span class="string">&#x27;实习生&#x27;</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 模糊查询运算符</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 匹配符： “_”匹配一个任意字符、<span class="operator">%</span>匹配一个多个任意字符</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> job <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;黄_&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> job <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;黄%&#x27;</span> </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 空<span class="keyword">NULL</span> 表示未知，没有，不是<span class="number">0</span>，不是空字符串</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 注意 判断空必须使用<span class="keyword">is</span>或者<span class="keyword">is</span> <span class="keyword">not</span> 来判断</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> person <span class="keyword">where</span> dep <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> person <span class="keyword">where</span> dep <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p><a name="wL1IK"></a></p>
<h4 id="4）group-by-分组"><a href="#4）group-by-分组" class="headerlink" title="(4）group by 分组"></a>(4）group by 分组</h4><p>分组的理解：相同的是一组，按照组来显示记录，几组就显示几条记录，从某种意义上来说类似于去重<br />分组的注意： 分组的时候，select显示的字段有约束条件，一是分组的组名，二是聚合函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sex,age <span class="keyword">from</span> <span class="keyword">group</span> <span class="keyword">by</span> sex <span class="operator">/</span><span class="operator">/</span> 错误，不能是sex、age两个，只能是se x一个</span><br><span class="line"><span class="keyword">select</span> sex <span class="keyword">from</span> <span class="keyword">group</span> <span class="keyword">by</span> sex <span class="operator">/</span><span class="operator">/</span> 正确</span><br><span class="line"><span class="keyword">select</span> sex,<span class="built_in">MAX</span>(age) 最大,<span class="built_in">MIN</span>(age) 最小,<span class="built_in">COUNT</span>(<span class="operator">*</span>) 个数,<span class="built_in">SUM</span>(age) 求和,<span class="built_in">AVG</span>(age) 平均 </span><br><span class="line"><span class="keyword">from</span> job <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br></pre></td></tr></table></figure>
<p><a name="k4qcv"></a></p>
<h4 id="5）HAVING-分组过滤的条件语句"><a href="#5）HAVING-分组过滤的条件语句" class="headerlink" title="(5）HAVING 分组过滤的条件语句"></a>(5）HAVING 分组过滤的条件语句</h4><p>注意：where和having都是条件语句<br />注意：where是对每一条记录进行过滤筛选<br />注意：having是对组进行过滤筛选。分组之后才能使用having</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> source s ,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> job <span class="keyword">group</span> <span class="keyword">by</span> s <span class="keyword">having</span> c<span class="operator">&gt;</span><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><a name="tK4Fd"></a></p>
<h4 id="6-ORDERF-BY-排序"><a href="#6-ORDERF-BY-排序" class="headerlink" title="(6)ORDERF BY 排序"></a>(6)ORDERF BY 排序</h4><p>默认按照升序排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> job <span class="keyword">order</span> <span class="keyword">by</span> age</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 升序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> job <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">ASC</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 降序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> job <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
<p>同时使用六个查询语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> position p,<span class="built_in">count</span> (<span class="operator">*</span>) c</span><br><span class="line"><span class="keyword">FROM</span> job</span><br><span class="line"><span class="keyword">where</span> age <span class="operator">&gt;</span><span class="number">20</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> p </span><br><span class="line"><span class="keyword">having</span> c<span class="operator">&gt;</span><span class="number">10</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<p><a name="odnXR"></a></p>
<h3 id="五）多表查询：子查询"><a href="#五）多表查询：子查询" class="headerlink" title="(五）多表查询：子查询"></a>(五）多表查询：子查询</h3><p>案例：查小刘的所在公司<br />多表连接的写法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> c.name 公司名 </span><br><span class="line"><span class="keyword">from</span> company c,<span class="keyword">member</span> m </span><br><span class="line"><span class="keyword">where</span> c.id<span class="operator">=</span>m.comid <span class="keyword">and</span> m.name<span class="operator">=</span><span class="string">&#x27;小刘&#x27;</span></span><br></pre></td></tr></table></figure>
<p><a name="rdwsM"></a></p>
<h4 id="（1）select-子查询"><a href="#（1）select-子查询" class="headerlink" title="（1）select 子查询"></a>（1）select 子查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> (<span class="keyword">select</span> name <span class="keyword">from</span> company <span class="keyword">where</span> id<span class="operator">=</span>comid) 公司</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">member</span> </span><br><span class="line"><span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小刘’</span></span><br></pre></td></tr></table></figure>
<p><a name="PvmoP"></a></p>
<h4 id="（2）-where-子查询"><a href="#（2）-where-子查询" class="headerlink" title="（2） where 子查询"></a>（2） where 子查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name 公司名</span><br><span class="line"><span class="keyword">from</span> company</span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span>(<span class="keyword">select</span> comid <span class="keyword">from</span> <span class="keyword">member</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小刘&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name 公司名</span><br><span class="line"><span class="keyword">from</span> company</span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> comid <span class="keyword">from</span> <span class="keyword">member</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小刘&#x27;</span> <span class="keyword">or</span> name<span class="operator">=</span><span class="string">&#x27;小黄&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><a name="pwxHs"></a></p>
<h4 id="（3）from子查询"><a href="#（3）from子查询" class="headerlink" title="（3）from子查询"></a>（3）from子查询</h4><p>注意 ：from子查询主要用于3张表以上的连接查询<br />举例：有abc三张表。先查询a和b，再用查询结果和c表连接查询</p>
<p>注意： select 和where是将查询结果当成【数据】<br />注意： select 和where是将查询结果当成【表】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> c.name form  (<span class="keyword">select</span> name n,comid,c <span class="keyword">from</span> <span class="keyword">member</span> <span class="keyword">where</span> n<span class="operator">=</span><span class="string">&#x27; 小刘&#x27;</span>) t,company c</span><br><span class="line"><span class="keyword">where</span> t.c<span class="operator">=</span>c.id.	</span><br></pre></td></tr></table></figure>
<p><a name="C9LVH"></a></p>
<h3 id="六-limit"><a href="#六-limit" class="headerlink" title="(六) limit"></a>(六) limit</h3><p>注意limit 通常于order by 一起用，主要有两个作用<br><a name="K2ma7"></a></p>
<h4 id="（1）分析top-n"><a href="#（1）分析top-n" class="headerlink" title="（1）分析top-n"></a>（1）分析top-n</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 使用一个参数</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> job <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span> limit <span class="number">5</span> <span class="operator">/</span><span class="operator">/</span> 提取降序前五个</span><br></pre></td></tr></table></figure>
<p><a name="lAorM"></a></p>
<h4 id="（2）-用于分页"><a href="#（2）-用于分页" class="headerlink" title="（2） 用于分页"></a>（2） 用于分页</h4><p>使用两个参数<br />参数一：表示起始位置<br />参数二：表示个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> job <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span> limit <span class="number">0</span>,<span class="number">10</span> 					<span class="operator">/</span><span class="operator">/</span>第一页</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> job <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span> limit <span class="number">10</span>,<span class="number">10</span>  				<span class="operator">/</span><span class="operator">/</span>第二页</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> job <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span> limit (n<span class="number">-1</span>)<span class="operator">*</span><span class="number">10</span>,<span class="number">10</span>  	<span class="operator">/</span><span class="operator">/</span>第三页</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SQL</category>
        <category>SQL常用命令</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>SQL常用</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16 双显卡安装教程</title>
    <url>/2023/06/24/Ubuntu%2016%20%E5%8F%8C%E6%98%BE%E5%8D%A1%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="referrer" content="no-referrer" />
  <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
  <title>Ubuntu 16 双显卡安装教程</title>
  <!-- <link rel="stylesheet" href="https://stackedit.io/style.css" /> -->
</head>

<body class="stackedit">
  <div class="stackedit__html"><p>整整安装了两天半,<br>
早上九点多到晚上十二点多,<br>
一直尝试了很多方法,<br>
重装两次系统.<br>
网上的教程把我给坑地明明白白,<br>
教程五花八门,看得我眼花缭乱,<br>
终于,老天有眼,<br>
在下午一点多的时候,<br>
终于搞定,<br>
如图你是16系统,你还是装为18或者19 的系统吧,<br>
因为bug真的很多<br>
教程如下:</p>
<ol>
<li>更换系统,改为19的,18应该也可以</li>
<li>打开软件与更新,</li>
<li>选择下面的图片第二项,(第一项我试过了,也成功,不过有bug,显示不正常,还是用390吧)</li>
<li>应用更改,<br>
待会弹出一个窗口,会让你设置密码,两次密码要输入一样<br>
<img src="https://img-blog.csdnimg.cn/20190726141412819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FoaGpoaGo=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<p>4.重启系统,之后会蓝屏(蓝屏是正常的),按任意键,选择第二个选项,回车,直到跳出一个输入框,输入你刚刚设置的密码,回车,重启,</p>
<p>5.进入系统,打开系统详情信息,可以看到"图像"已经是MK150显卡,完美,<br>
<img src="https://img-blog.csdnimg.cn/20190726142312140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FoaGpoaGo=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
打开NVIDIA X Server Settings ,可以看到成功画面如下,不然,就是你操作不当失败了<br>
<img src="https://img-blog.csdnimg.cn/20190726142244375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FoaGpoaGo=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><a id="_26"></a>最后,我想说,网上的一些教程真是</h2>
<h2><a id="_27"></a>辣鸡辣鸡辣鸡辣鸡!!!</h2>
</div>
</body>

</html>
]]></content>
      <categories>
        <category>Ubuntu</category>
        <category>双显卡安装教程</category>
      </categories>
      <tags>
        <tag>Ubuntu 16</tag>
        <tag>双显卡安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 18.04 Docker 配置代理连接网络(2023811)</title>
    <url>/2023/08/22/Ubuntu%2018.04%20Docker%20%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C(2023811)/</url>
    <content><![CDATA[<br/>

<h2 id="Ubuntu-18-04-Docker-配置代理连接网络"><a href="#Ubuntu-18-04-Docker-配置代理连接网络" class="headerlink" title="Ubuntu 18.04 Docker 配置代理连接网络"></a>Ubuntu 18.04 Docker 配置代理连接网络</h2><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<blockquote>
<p>创建目录  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 创建http-proxy.conf配置文件  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line">vim /etc/systemd/system/docker.service.d/http-proxy.conf</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在http-proxy.conf文件中添加如下内容，注意【service】是必须要填写的（根据自家的代理情况填写，参考资料有HTTPS的说明）</p>
<p>例如可以使用clash代理后的 127.0.0.1:7890</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Service\]**  </span><br><span class="line">Environment=&quot;HTTP\_PROXY=http://127.0.0.1:7890/&quot; &quot;NO\_PROXY=localhost,127.0.0.1&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> Flush变更  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重启Docker  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>验证配置是否已加载  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl show --property=Environment docker  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>当有如下输出  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Environment=HTTP\_PROXY=http://127.0.0.1:7890/ NO\_PROXY=localhost,127.0.0.1  </span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>来自用户chinyan的文章</title>
    <url>/2023/06/23/chin/</url>
    <content><![CDATA[<h2 id="开始之前的准备"><a href="#开始之前的准备" class="headerlink" title="开始之前的准备"></a><a href="#" title="开始之前的准备"></a>开始之前的准备</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a><a href="#" title="环境准备"></a>环境准备</h3><p>在开始前要确保本地已经安装好了<a href="https://git-scm.com/downloads">git</a>和稳定版本的<a href="https://nodejs.org/en/">node.js</a> ，安装和配置的方式在这里就不再复述，相信这个对大家来讲都不是什么大问题。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><a href="#" title="参考文档"></a>参考文档</h3><p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p>
<h2 id="那就开始吧"><a href="#那就开始吧" class="headerlink" title="那就开始吧"></a><a href="#" title="那就开始吧"></a>那就开始吧</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a href="#" title="安装"></a>安装</h3><p>首先来全局安装一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli  </span><br></pre></td></tr></table></figure>
<p>macos系统在安装的时候可能会报错<code>EACCES</code>，是因为安装需要管理员权限，<code>sudo -s</code>回车，输入密码获得管理员权限，然后再次尝试安装即可。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><a href="#" title="初始化"></a>初始化</h3><p>安装完成后在本地建一个项目文件夹，在文件夹下打开<code>git bash here</code>运行命令。  </p>
<p>mac可直接终端，进入到文件夹目录下运行命令初始化项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init  </span><br></pre></td></tr></table></figure>
<p>如果出现报错也莫慌，多半是网络问题造成的，多试几次就好了，下图为初始化成功截图。<br><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202208312303581.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202208312303581.png"></a></p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a><a href="#" title="目录结构"></a>目录结构</h3><p>初始化完成后可以看到以下这些主要目录<br><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202208312306580.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202208312306580.png"></a><br>简单介绍下文件结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public        // 最终所见网页的所有内容  </span><br><span class="line">node\_modules  // 插件以及hexo所需node.js模块  </span><br><span class="line">\_config.yml   // 站点配置文件，设定一些公开信息等  </span><br><span class="line">package.json  // 应用程序信息，配置hexo运行所需js包  </span><br><span class="line">scaffolds     // 模板文件夹，新建文章，会默认包含对应模板内容  </span><br><span class="line">themes        // 存放主题文件，hexo根据主题生成静态网页（速度贼快）  </span><br><span class="line"><span class="built_in">source</span>        // 用于存放用户资源（除 posts 文件夹，其余命名方式为 “ + 文件名”的文件被忽略）  </span><br></pre></td></tr></table></figure>
<p>日常写文的操作都在 source&#x2F;_post下，写文主要是用的<a href="https://www.runoob.com/markdown/md-tutorial.html">Markdown</a>语法，不会用的可以先去补补课。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a><a href="#" title="运行"></a>运行</h3><p>接下来让我们运行一下吧</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s  </span><br></pre></td></tr></table></figure>
<p>运行成功后会提醒你在<a href="http://localhost:4000/">本地</a>进行预览你的博客<br><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202208312317891.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202208312317891.png"></a><br>本地打开的页面<br><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202208312316281.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202208312316281.png"></a></p>
<p>博客页面</p>
<p>到这里本地的任务已经基本是完成了，当然，我们想要的可不仅仅是如此。</p>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a><a href="#" title="主题"></a>主题</h3><p>接下来以<a href="https://butterfly.js.org/">butterfly</a>小蝴蝶主题为例，先安装主题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://gitee.com/immyw/hexo-theme-butterfly.git themes/butterfly  </span><br></pre></td></tr></table></figure>
<p>还需要安装pug以及stylus的渲染器，如果没有安装，预览界面可能会出现一些你不喜欢的“小”问题，如下<br><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209010012464.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209010012464.png"></a></p>
<p>出了点小状况</p>
<p>在控制台全局安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save  </span><br></pre></td></tr></table></figure>
<p>安装完成后修改一下配置文件<br>网站根目录下找到<code>_config.yml</code>文件，修改主题为<code>butterfly</code>后保存（注意文件格式）<br><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209010007503.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209010007503.png"></a></p>
<p>就是这个</p>
<p>然后运行预览一下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s  </span><br></pre></td></tr></table></figure>
<p>运行成功<br><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202208310033427.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202208310033427.png"></a><br>看一下效果，大气<br><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209010013318.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209010013318.png"></a></p>
<p>往下接着划，完美<br><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209010015548.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209010015548.png"></a></p>
<p>嘿，细节</p>
<p>到这里，本地代码要做的事情也就差不多了，如果想整的更漂亮一些或者想换别的主题就需要你自己去研究一下啦。接下来就准备上线吧，城堡建好了怎么着也得给别人看一下的吧！</p>
<h3 id="上线"><a href="#上线" class="headerlink" title="上线"></a><a href="#" title="上线"></a>上线</h3><p>终于要准备上线了，作为平民窟代表，一个极低成本的博客当然也是需求的一部分，那一个免费博客存放服务器当然也是必不可少了。<br><strong>GitHub Pages</strong>就刚好符合我们的要求，<strong>GitHub Pages</strong>允许用户的任何一个Repo的gh-pages分支上的代码可以经由HTTP访问到。类似提供了静态文件服务。<br>首先，我们要新建一个和用户名同名的仓库。进入到github，点击自己的头像选择<strong>Your repositories</strong>，进入仓库页面。然后<strong>New</strong>一个新仓库，仓库名格式为<strong>用户名.github.io</strong>，用户名就是你登陆的名字<br><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209012332115.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209012332115.png"></a></p>
<p>看图片教程</p>
<p>然后回到我们的代码，修改根目录下的 <code>_config.yml</code>，配置<code>deploy</code>相关信息<br><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209012340817.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209012340817.png"></a></p>
<p>这样子</p>
<p>这些字段代表的东西</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy \<span class="comment"># 这不需要，忽略这个，这个完全是我手滑多打出来的一个，小失误！  </span></span><br><span class="line"><span class="built_in">type</span>   \<span class="comment"># 上传类型，用git就行  </span></span><br><span class="line">repo   \<span class="comment"># 仓库地址，clone代码的时候那个HTTPS地址  </span></span><br><span class="line">branch \<span class="comment"># 代码分支，以你上传的主分支为准  </span></span><br><span class="line">token  \<span class="comment"># GitHub 的 Personal access tokens，看下图  </span></span><br></pre></td></tr></table></figure>
<p><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209012349476.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209012349476.png"></a></p>
<p>获取token</p>
<p>好了，配置完后安装一下<code>hexo-deployer-git</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save  </span><br></pre></td></tr></table></figure>
<p>安装完成后运行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d  </span><br></pre></td></tr></table></figure>
<p>然后你看到下面这个东西就表示推送成功，打开仓库就能看到你刚刚推送的代码。<br><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209012358888.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209012358888.png"></a></p>
<p>推送成功</p>
<p>当然，到这里还没有结束，还有最后一步。</p>
<h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a><a href="#" title="最后一步"></a>最后一步</h3><p>打开你刚刚创建的仓库，找到<strong>GitHub Pages</strong>页面，按下图操作，然后大功告成！<br><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209020005349.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209020005349.png"></a></p>
<p>大功告成</p>
<h2 id="如果你也刚好有一个域名"><a href="#如果你也刚好有一个域名" class="headerlink" title="如果你也刚好有一个域名"></a><a href="#" title="如果你也刚好有一个域名"></a>如果你也刚好有一个域名</h2><h3 id="有域名，那更好了！"><a href="#有域名，那更好了！" class="headerlink" title="有域名，那更好了！"></a><a href="#" title="有域名，那更好了！"></a>有域名，那更好了！</h3><p>如果你也跟我一样，刚好有一个域名，那么你就可以把github的博客地址解析到你自己的域名上，岂不美哉。<br>因为我的域名是之前从腾讯转到阿里的，那这里就以阿里云为例，先到阿里云的域名控制台找到自己的域名点解析<br>如果没有解析记录的话就新增一条，然后按下图进行配置<br><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209032342661.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209032342661.png"></a></p>
<p>云解析DNS</p>
<p>现在买一个域名的话也不算很贵，第一次买挑一个喜欢的域名一次多充值几年，四舍五入也是等于白嫖了！而且腾讯和阿里也经常会有活动，如果有需求的话可以考虑买一个。</p>
<h2 id="如果你刚好有一个服务器"><a href="#如果你刚好有一个服务器" class="headerlink" title="如果你刚好有一个服务器"></a><a href="#" title="如果你刚好有一个服务器"></a>如果你刚好有一个服务器</h2><h3 id="如果你恰好财力雄厚"><a href="#如果你恰好财力雄厚" class="headerlink" title="如果你恰好财力雄厚"></a><a href="#" title="如果你恰好财力雄厚"></a>如果你恰好财力雄厚</h3><p>如果你刚好有一个服务器，那么，关我什么事，我又没有服务器，想知道怎么部署就自己去百度！或者滑到下面看参考文章，当然也可能有一天我有时间，自己去搭建了一个服务器，那就另当别论了。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><a href="#" title="其他"></a>其他</h2><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a><a href="#" title="热更新"></a>热更新</h3><p>你会发现每次本地文件修改后都要重新运行一下<code>hexo s</code>才会生效。所以，怎么会有人不喜欢热更新啊。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\<span class="comment"># 为了在修改文件后不再重复启动，将本地项目设置成热更新。  </span></span><br><span class="line">$ npm install hexo-server --save  </span><br><span class="line">\<span class="comment"># 安装完成后，输入以下命令以启动服务器。  </span></span><br><span class="line">$ hexo server  </span><br><span class="line">\<span class="comment"># 如果想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，执行以下命令更换端口。  </span></span><br><span class="line">$ hexo server -p 5000  </span><br></pre></td></tr></table></figure>
<h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a><a href="#" title="图床"></a>图床</h3><p>写博客的话虽然可以吧图片放在静态文件进行引用，但是太多图片会占据很大的空间，所以还是建议整一个自己的图床来使用。<br>下一期再专门出一期教程来配置图床，<a href="#">点我直达</a></p>
<h2 id="可能会遇到的坑"><a href="#可能会遇到的坑" class="headerlink" title="可能会遇到的坑"></a><a href="#" title="可能会遇到的坑"></a>可能会遇到的坑</h2><h3 id="github部署问题"><a href="#github部署问题" class="headerlink" title="github部署问题"></a><a href="#" title="github部署问题"></a>github部署问题</h3><p>不用自己去部署！不用自己去部署！不用自己去部署！重要的事情说三遍。github初始化的仓库什么都没有，这个不用管，提交命令是集成在hexo的命令里的，按照上面的步骤一步步来就可以了，不用先拉仓库代码。</p>
<h3 id="端口已占用"><a href="#端口已占用" class="headerlink" title="端口已占用"></a><a href="#" title="端口已占用"></a>端口已占用</h3><p><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202208312327377.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202208312327377.png"></a></p>
<p>端口已占用</p>
<p>如果想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，执行以下命令更换端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server -p 5000  </span><br></pre></td></tr></table></figure>
<h3 id="推送不上去1"><a href="#推送不上去1" class="headerlink" title="推送不上去1"></a><a href="#" title="推送不上去1"></a>推送不上去1</h3><p>报错<code>ERROR Deployer not found: git</code>，反思一下自己是不是没有好好看教程，这是因为没安装<code>hexo-deployer-git</code>插件，安装后后再跑一下<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>命令就可以推送了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```bash</span><br><span class="line">npm install hexo-deployer-git --save  </span><br></pre></td></tr></table></figure>
<h3 id="推送不上去2"><a href="#推送不上去2" class="headerlink" title="推送不上去2"></a><a href="#" title="推送不上去2"></a>推送不上去2</h3><p>你会看到下面这样的报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FATAL Something<span class="string">&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html  </span></span><br><span class="line"><span class="string">Error: Spawn failed  </span></span><br></pre></td></tr></table></figure>
<p><a href="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209182333878.png"><img src="https://chinyan.oss-cn-hangzhou.aliyuncs.com/img/202209182333878.png"></a></p>
<p>推送不上去</p>
<p>别担心，网不好而已，在国内github的网站连接很不稳定，这确实挺膈应人，不过多试几次就好了，加油！</p>
<h3 id="推送不上去"><a href="#推送不上去" class="headerlink" title="推送不上去"></a><a href="#" title="推送不上去"></a>推送不上去</h3><p>报错信息 <code>error: invalid active developer path</code>  </p>
<p>这个是git的错误，一般会在升级系统后出现，只需要执行以下步骤即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\<span class="comment"># 安装 xcode-select  </span></span><br><span class="line">xcode-select --install  </span><br><span class="line">\<span class="comment"># 在 xcode-select 质量安装好后检查一下git指令的帮助信息  </span></span><br><span class="line">git -h  </span><br></pre></td></tr></table></figure>
<p>然后大功告成！</p>
<h3 id="运行报错"><a href="#运行报错" class="headerlink" title="运行报错"></a><a href="#" title="运行报错"></a>运行报错</h3><p>运行后打开页面后没有显示博客，而是空白页面上显示一串 <code>extends includes/layout.pug block content include ./includes/mixins/post-ui.pug #recent-posts.recent-posts +postUI include includes/pagination.pug</code><br>这个问题大概率是你项目复制到其他地方，然后依赖没有装全</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\<span class="comment"># 安装依赖  </span></span><br><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive  </span><br><span class="line">\<span class="comment"># 安装完后运行  </span></span><br><span class="line">hexo hexo clean &amp;&amp; hexo g &amp;&amp; hexo s  </span><br></pre></td></tr></table></figure>
<p>解决<br>如果 <code>hexo d</code> 后 <code>ERROR Deployer not found: git</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\<span class="comment"># 安装  </span></span><br><span class="line">npm install --save hexo-deployer-git​  </span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>docker常用命令</title>
    <url>/2023/06/22/dockercomend/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>作用</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>查看镜像列表</td>
<td>docker conainer ls</td>
</tr>
<tr>
<td>查看镜像列表</td>
<td>docker ps -a</td>
</tr>
<tr>
<td>停用指定镜像</td>
<td>docker stop [containerId]</td>
</tr>
<tr>
<td>启用指定镜像</td>
<td>docker start [containerId]</td>
</tr>
<tr>
<td>进入指定容器</td>
<td>docker exec -it [containerId] &#x2F;bin&#x2F;sh</td>
</tr>
<tr>
<td>退出容器</td>
<td>exit</td>
</tr>
<tr>
<td>查看容器状态</td>
<td>docker inspect [containerId]</td>
</tr>
<tr>
<td>查看容器端口信息</td>
<td>docker port [containerId]</td>
</tr>
<tr>
<td>查询容器日志信息</td>
<td>docker logs -f [containerId]</td>
</tr>
<tr>
<td>删除镜像</td>
<td>docker rm [containerId]</td>
</tr>
<tr>
<td>查询docker映射</td>
<td>docker inspect [containerId] &amp;#124; grep Mounts -A 20</td>
</tr>
<tr>
<td>查看日志</td>
<td>docker logs –since 30m [containerId]</td>
</tr>
<tr>
<td>删除所有的容器</td>
<td>docker stop $(docker ps -q) &amp; docker rm $(docker ps -q)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>切换 root 账号</td>
<td>sudo su - root</td>
</tr>
<tr>
<td>查看被占用的端口的进程号</td>
<td>netstat -ano &amp;#124; findstr [端口号]</td>
</tr>
<tr>
<td>根据进程号查看进程名</td>
<td>tasklist &amp;#124; findstr [进程号]</td>
</tr>
<tr>
<td>根据进程号杀死进程</td>
<td>taskkill &#x2F;f &#x2F;pid [进程号]</td>
</tr>
<tr>
<td>根据进程名称杀死进程</td>
<td>taskkill &#x2F;f &#x2F;t &#x2F;i [进程名称]</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker常用命令</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>docker常用</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2023/08/22/docker%EF%BC%882023811)/</url>
    <content><![CDATA[<h2 id="Docker-上手"><a href="#Docker-上手" class="headerlink" title="Docker 上手"></a>Docker 上手</h2><h3 id="一、-镜像操作"><a href="#一、-镜像操作" class="headerlink" title="一、 镜像操作"></a>一、 镜像操作</h3><h4 id="1-列出镜像"><a href="#1-列出镜像" class="headerlink" title="1. 列出镜像"></a>1. 列出镜像</h4><p><strong>「语句：」</strong> <code>docker images</code></p>
<ul>
<li><strong>「REPOSITORY」</strong>：表示镜像的仓库源</li>
<li><strong>「TAG」</strong>：镜像的标签</li>
<li><strong>「IMAGE ID」</strong>：镜像ID</li>
<li><strong>「CREATED」</strong>：镜像创建时间</li>
<li><strong>「SIZE」</strong>：镜像大小</li>
</ul>
<h4 id="2-查找镜像"><a href="#2-查找镜像" class="headerlink" title="2. 查找镜像"></a>2. 查找镜像</h4><p><strong>「语句：」</strong> <code>docker search $&#123;image_name&#125;</code></p>
<ul>
<li><strong>「NAME」</strong>：镜像仓库源的名称</li>
<li><strong>「DESCRIPTION」</strong>：镜像的描述</li>
<li><strong>「starts」</strong>：用户评价，反应一个镜像的受欢迎程度</li>
<li><strong>「OFFICIAL」</strong>：是否docker官方发布</li>
<li><strong>「auto commit」</strong>：自动构建，表示该镜像由 Docker Hub 自动构建流程创建的</li>
</ul>
<h4 id="3-拉取镜像"><a href="#3-拉取镜像" class="headerlink" title="3. 拉取镜像"></a>3. 拉取镜像</h4><p><strong>「语句：」</strong> <code>docker pull $&#123;image_name&#125;:$&#123;image_version&#125;</code></p>
<h4 id="4-删除镜像"><a href="#4-删除镜像" class="headerlink" title="4. 删除镜像"></a>4. 删除镜像</h4><ul>
<li><p><strong>「删除单个：」</strong></p>
<p><code>docker rmi $&#123;image_name&#125; (or $&#123;id&#125;)</code></p>
</li>
<li><p><strong>「删除多个：」</strong></p>
<p><code>docker rmi $&#123;image_name&#125;/$&#123;id&#125; $&#123;image_name&#125;/$&#123;id&#125; ...</code></p>
</li>
<li><p><strong>「删除所有：」</strong></p>
<p><code>docker rmi</code> <strong>「`docker images -q`」</strong></p>
</li>
</ul>
<h4 id="5-查看镜像元数据"><a href="#5-查看镜像元数据" class="headerlink" title="5. 查看镜像元数据"></a>5. 查看镜像元数据</h4><p><code>docker inspect $&#123;image_name&#125;</code></p>
<p><code>docker inspect -f =&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; $&#123;image_name&#125;</code></p>
<ul>
<li><strong>「-f」</strong>：可用 <strong>「-format」</strong> 代替</li>
</ul>
<h3 id="二、容器操作"><a href="#二、容器操作" class="headerlink" title="二、容器操作"></a>二、容器操作</h3><h4 id="1-创建容器"><a href="#1-创建容器" class="headerlink" title="1. 创建容器"></a>1. 创建容器</h4><p><code>docker run [option] --name=$&#123;name&#125; image command [args...]</code></p>
<p><strong>「option 选项」</strong>：</p>
<ul>
<li><code>-i</code>：交互式容器</li>
<li><code>-t</code>：tty，终端</li>
<li><code>-d</code>：后台运行，并且打印出容器 <strong>「id」</strong></li>
</ul>
<p><strong>「示例」</strong>：</p>
<p><code>docker run -i -t -d --name=centOS1 centos /bin/bash</code></p>
<p><strong>「&#x3D;」</strong></p>
<p><code>docker run -itd --name=centOS1 centos /bin/bash</code></p>
<p><strong>「注：」</strong> 创建的容器名称不能重复</p>
<h4 id="2-进入容器"><a href="#2-进入容器" class="headerlink" title="2. 进入容器"></a>2. 进入容器</h4><p><strong>「方式1：」</strong></p>
<p><code>docker attach $&#123;name&#125;/$&#123;id&#125;</code></p>
<ul>
<li>示例：</li>
</ul>
<p><code>docker attach centOS1</code></p>
<p><strong>「注：」</strong> 在容器内使用 <strong>「exit」</strong> 退出容器时，<strong>「容器会停止」</strong></p>
<p><strong>「方式2：」</strong></p>
<p><code>docker exec -it $&#123;name&#125;/$&#123;id&#125; /bin/bash</code></p>
<ul>
<li>示例：</li>
</ul>
<p><code>docker exec -it centOS1 /bin/bash</code><strong>「注：」</strong> 在容器内使用 <strong>「exit」</strong> 退出容器时，<strong>「容器不会停止」</strong></p>
<h4 id="3-查看容器"><a href="#3-查看容器" class="headerlink" title="3. 查看容器"></a>3. 查看容器</h4><ul>
<li><strong>「查看正在运行的容器」</strong></li>
</ul>
<p><code>docker ps</code></p>
<ul>
<li><strong>「查看历史运行过的容器」</strong></li>
</ul>
<p><code>docker ps -a</code></p>
<ul>
<li><strong>「查看最后一次运行的容器」</strong></li>
</ul>
<p><code>docker ps -l</code></p>
<h4 id="4-停止容器"><a href="#4-停止容器" class="headerlink" title="4. 停止容器"></a>4. 停止容器</h4><p><code>docker stop $&#123;name&#125;/$&#123;id&#125;</code></p>
<h4 id="5-启动容器"><a href="#5-启动容器" class="headerlink" title="5. 启动容器"></a>5. 启动容器</h4><p><code>docker start $&#123;name&#125;/$&#123;id&#125;</code></p>
<h4 id="6-删除容器"><a href="#6-删除容器" class="headerlink" title="6. 删除容器"></a>6. 删除容器</h4><ul>
<li><strong>「删除一个容器」</strong></li>
</ul>
<p><code>docker rm $&#123;name&#125;/$&#123;id&#125;</code></p>
<ul>
<li><strong>「删除多个容器」</strong></li>
</ul>
<p><code>docker rm $&#123;name1&#125;/$&#123;id1&#125; $&#123;name2&#125;/$&#123;id2&#125; ...</code></p>
<ul>
<li><strong>「删除多个容器」</strong></li>
</ul>
<p><code>docker rm</code> <strong>「` docker ps -a -q`」</strong></p>
<h4 id="7-查看容器元数据"><a href="#7-查看容器元数据" class="headerlink" title="7. 查看容器元数据"></a>7. 查看容器元数据</h4><p><code>docker inspect $&#123;name&#125;</code></p>
<p><code>docker inspect -f =&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; $&#123;name&#125;</code></p>
<ul>
<li><strong>「-f」</strong>：可用 <strong>「-format」</strong> 代替</li>
</ul>
<h4 id="8-查看容器日志"><a href="#8-查看容器日志" class="headerlink" title="8. 查看容器日志"></a>8. 查看容器日志</h4><p><code>docker logs $&#123;name&#125;/$&#123;id&#125;</code></p>
<h4 id="9-文件拷贝"><a href="#9-文件拷贝" class="headerlink" title="9. 文件拷贝"></a>9. 文件拷贝</h4><p><code>docker cp 需要拷贝的文件或目录 容器名称:容器目录</code></p>
<p><strong>「示例：」</strong><code>docker cp 1.txt c2:/root</code></p>
<h4 id="10-目录挂载"><a href="#10-目录挂载" class="headerlink" title="10. 目录挂载"></a>10. 目录挂载</h4><p>目录挂载就是将宿主机的目录与容器内的努力进行映射，这样我们改变宿主机挂载目录下的内容时，容器内对应挂载目录里面的目录也会改变</p>
<p><strong>「语句：」</strong> 使用 <strong>「-v」</strong> 进行挂载<code>docker run ‐id ‐‐name=centOS1 ‐v /opt/:/usr/local centos</code></p>
<p>如果权限不足，我们应当使用：</p>
<p><code>docker run ‐id ‐‐privileged=true ‐‐name=c4 ‐v /opt/:/usr/local/myhtml centos</code></p>
<h3 id="三、镜像制作"><a href="#三、镜像制作" class="headerlink" title="三、镜像制作"></a>三、镜像制作</h3><p>我们不仅仅可以从 <strong>「Docker Hub」</strong> 上拉取镜像进行创建容器，我们还可以手动定制 <strong>「docker」</strong> 系统镜像，目前构建镜像的方式有两种：</p>
<ul>
<li>使用 <code>docker commit</code> 命令</li>
<li>使用 <code>docker build</code> 配合 <code>Dockerfile</code> 文件</li>
</ul>
<h4 id="1-docker-commit"><a href="#1-docker-commit" class="headerlink" title="1. docker commit"></a>1. docker commit</h4><h5 id="1）「制作镜像」"><a href="#1）「制作镜像」" class="headerlink" title="1）「制作镜像」"></a>1）<strong>「制作镜像」</strong></h5><p>使用 <code>docker commit</code> 制作镜像前，我们需要一个正在运行的容器：</p>
<ul>
<li><strong>「步骤1」</strong></li>
</ul>
<p>我们需要先拉取一个 <strong>「centOS」</strong> 作为我们的基础镜像：<code>docker pull centos</code></p>
<ul>
<li><strong>「步骤2」</strong></li>
</ul>
<p>运行刚刚拉取到的镜像：<code>docker run -it --name=centOS1 centos:latest</code></p>
<ul>
<li><strong>「步骤3」</strong></li>
</ul>
<p>在容器中安装环境：</p>
<ol>
<li><strong>「tomcat」</strong></li>
</ol>
<p>上传 <strong>「tomcat」</strong> 安装包：</p>
<p><code>docker cp apache‐tomcat‐8.5.54.tar.gz centOS1:/root/</code></p>
<p>安装 <strong>「tomcat」</strong>：</p>
<p><code>tar ‐zxvf apache‐tomcat‐8.5.54.tar.gz ‐C /usr/local/</code></p>
<p>编辑<strong>「tomcat」</strong> 下的 <strong>「&#x2F;bin&#x2F;setclsspath.sh」</strong> 文件，添加如下内容：</p>
<p><code>export JAVA_HOME=/usr/local/jdk1.8.0_161   export JRE_HOME=/usr/local/jdk1.8.0_161/jre   </code></p>
<ol start="2">
<li><strong>「JDK」</strong></li>
</ol>
<p>上传 <strong>「JDK」</strong> 安装包：</p>
<p><code>docker cp jdk‐8u161‐linux‐x64.tar.gz centOS1:/root/</code></p>
<p>安装 <strong>「JDK」</strong>：</p>
<p><code>tar ‐zxvf jdk‐8u161‐linux‐x64.tar.gz ‐C /usr/local/</code></p>
<p>编辑**&#x2F;etc&#x2F;profile** 文件，添加如下内容：</p>
<p><code>JAVA_HOME=/usr/local/jdk1.8.0_161   export PATH=$JAVA_HOME/bin:$PATH   </code></p>
<ul>
<li>步骤4</li>
</ul>
<p>将我们正在运行的容器提交为一个新的镜像</p>
<p><code>docker commit centOS1 cbucImage</code></p>
<h5 id="2）「端口映射」"><a href="#2）「端口映射」" class="headerlink" title="2）「端口映射」"></a>2）<strong>「端口映射」</strong></h5><ul>
<li><strong>「步骤1」</strong></li>
</ul>
<p>启动容器：<code>docker run ‐itd ‐‐name=t1 ‐p 8888:8080 cbucImage /bin/bash</code></p>
<ul>
<li><strong>「步骤2」</strong></li>
</ul>
<p>运行tomcat：<code>docker exec t1 /usr/local/apache‐tomcat‐7.0.47/bin/startup.sh</code></p>
<p>这样子我们就可以通过 <code>http://ip:port</code> 来访问页面了</p>
<h5 id="3）「镜像打包」"><a href="#3）「镜像打包」" class="headerlink" title="3）「镜像打包」"></a>3）<strong>「镜像打包」</strong></h5><p><strong>「打包镜像」</strong>：</p>
<p><code>docker save ‐o /mnt/myImage.tar cbucImage</code></p>
<p><strong>「在其他服务器中使用镜像：」</strong></p>
<p><code>docker load -i myImage.tar</code></p>
<h5 id="4）「容器打包」"><a href="#4）「容器打包」" class="headerlink" title="4）「容器打包」"></a>4）<strong>「容器打包」</strong></h5><p>打包容器：</p>
<p><code>docker export ‐o /mnt/mycentos.tar centOS1</code></p>
<p>导入容器：</p>
<p><code>docker import mycentos.tar centOS2:latest</code></p>
<h4 id="2-docker-builder"><a href="#2-docker-builder" class="headerlink" title="2. docker builder"></a>2. docker builder</h4><p><strong>「Dockerfile」</strong>使用基本的基于<strong>「DSL」</strong>语法的指令来构建一个Docker镜像，之后使用<strong>「docker」****「builder」</strong>命令基于该<strong>「Dockerfile」</strong>中的指令构建一个新的镜像</p>
<h5 id="1）「DSL-语法」"><a href="#1）「DSL-语法」" class="headerlink" title="1）「DSL 语法」"></a>1）<strong>「DSL 语法」</strong></h5><p>关键词</p>
<p>解释</p>
<p>FROM  基础镜像</p>
<p>MAINTAINER  维护者信息</p>
<p>RUN	安装软件</p>
<p>ADD    COPY 文件，会自动解压</p>
<p>WORKEDIR     cd 切换工作目录</p>
<p>VOLUME 目录挂载</p>
<p>EXPOSE  内部服务端口</p>
<p>CMD  执行 Dockerfile 中的命令</p>
<p>ENV 设置环境变量</p>
<p><strong>「解析：」</strong></p>
<ul>
<li><strong>「1. FROM」</strong></li>
</ul>
<p>指定基础 <strong>「image」</strong>。必须指定且需要在<strong>「Dockerfile」</strong>其他指令的前面。后续的指令都依赖于该指令指定的<strong>「image」</strong>。<strong>「FROM」</strong>指令指定的基础image可以是官方远程仓库中的，也可以位于本地仓库。FROM命令告诉<strong>「docker」</strong>我们构建的镜像是以哪个(发行版)镜像为基础的。如果在同一个<strong>「Dockerfile」</strong>中创建多个镜像时，可以使用多个 <strong>「FROM」</strong> 指令。</p>
<p><strong>「格式：」</strong></p>
<p><code>FROM &lt;image&gt;</code> 或者 <code>FROM &lt;image&gt;:&lt;tag&gt;</code></p>
<ul>
<li><strong>「2. MAINTAINER」</strong></li>
</ul>
<p>指定镜像创建者信息。用于将<strong>「image」</strong>的制作者相关的信息写入到<strong>「image」</strong>中。当我们对该<strong>「image」</strong>执行<strong>「docker inspect」</strong>命令时，输出中有相应的字段记录该信息。</p>
<p><strong>「格式：」</strong></p>
<p><code>MAINTAINER &lt;name&gt;</code></p>
<ul>
<li><strong>「3. RUN」</strong></li>
</ul>
<p>安装软件使用。可以运行任何被基础image<strong>「支持的命令」</strong>。如基础<strong>「image」</strong>选择了<strong>「ubuntu」</strong>，那么软 件管理部分只能使用<strong>「ubuntu」</strong>的命令。</p>
<p><strong>「格式：」</strong></p>
<p><code>RUN &lt;command&gt;</code></p>
<ul>
<li><strong>「4. CMD」</strong></li>
</ul>
<p>设置 <strong>「container」</strong> 启动时执行的操作。该操作可以是执行自定义脚本，也可以是执行系统命令。该指令只能在文件中存在一次，如果有多个，则只执行最后一条。</p>
<p><strong>「格式：」</strong></p>
<p><code>CMD command param1 param2</code></p>
<ul>
<li><strong>「5. ENTRYPOINT」</strong></li>
</ul>
<p>设置<strong>「container」</strong>启动时执行的操作，可以多次设置，但是只有最后一个有效。</p>
<p><strong>「格式：」</strong><code>ENTRYPOINT command param1 param2</code></p>
<p><strong>「场景1：」</strong></p>
<p>独自使用时，如果你还使用了<strong>「CMD」</strong>命令且<strong>「CMD」</strong>是一个完整的可执行的命令，那么<strong>「CMD」</strong>指令和<strong>「ENTRYPOINT」</strong>会互相覆盖，只有最后一个<strong>「CMD」</strong>或者<strong>「ENTRYPOINT」</strong>有效。</p>
<p>例：这个时候只有 <strong>「ENTRYPOINT」</strong> 会执行</p>
<p><code>CMD ls -l   ENTRYPOINT ls ‐l   </code></p>
<p><strong>「场景2：」</strong></p>
<p>和<strong>「CMD」</strong>指令配合使用来指定<strong>「ENTRYPOINT」</strong>的默认参数，这时<strong>「CMD」</strong>指令不是一个完整的可执行命令，仅仅是参数部分。<strong>「ENTRYPOINT」</strong>指令只能使用<strong>「JSON」</strong>方式指定执行命令，而不能指定参数。</p>
<p>例：</p>
<p><code>CMD [&quot;‐l&quot;]   ENTRYPOINT [&quot;/usr/bin/ls&quot;]   </code></p>
<ul>
<li><strong>「6. USER」</strong></li>
</ul>
<p>设置 <strong>「container」</strong> 容器的用户，默认是 <strong>「root」</strong> 用户</p>
<p><strong>「格式：」</strong></p>
<p><code># 指定memcached的运行用户   ENTRYPOINT [&quot;memcached&quot;]   USER daemon   或者   ENTRYPOINT [&quot;memcached&quot;, &quot;‐u&quot;, &quot;daemon&quot;]   </code></p>
<ul>
<li><strong>「7. EXPOSE」</strong></li>
</ul>
<p>指定容器需要映射到宿主机器的端口。当你需要访问容器的时候，可以不是用容器的<strong>「IP」</strong>地址而是使用宿主机器的<strong>「IP」</strong>地址和映射后的端口。要完成整个操作需要两个步骤，首先在Dockerfile使用<strong>「EXPOSE」</strong>设置需要映射的容器端口，然后在运行容器的时候指定 <strong>「‐p」</strong> 选项加上<strong>「EXPOSE」</strong>设置的端口，这样<strong>「EXPOSE」</strong>设置的端口号会被随机映射成宿主机器中的一个端口号。也可以指定需要映射到宿主机器的那个端口，这时要确保宿主机器上的端口号没有被使用。<strong>「EXPOSE」</strong>指令可以一次设置多个端口号，相应的运行容器的时候，可以配套的多次使用 <strong>「‐p」</strong> 选项。</p>
<p><strong>「格式：」</strong></p>
<p><code>EXPOSE &lt;port&gt; [&lt;port&gt;...]   # 映射一个端口   EXPOSE port1   # 相应的运行容器使用的命令   docker run ‐p port1 image   # 映射多个端口   EXPOSE port1 port2 port3   # 相应的运行容器使用的命令   docker run ‐p port1 ‐p port2 ‐p port3 image   # 还可以指定需要映射到宿主机器上的某个端口号   docker run ‐p host_port1:port1 ‐p host_port2:port2 ‐p host_port3:port3 image   </code></p>
<ul>
<li><strong>「8. ENV」</strong></li>
</ul>
<p>用于设置环境变量。设置了后，后续的<strong>「RUN」</strong>命令都可以使用，<strong>「container」</strong>启动后，可以通过<strong>「docker inspect」</strong> 查看这个环境变量，也可以通过在<strong>「docker run ‐‐env key&#x3D;value」</strong>时设置或修改环境变量。</p>
<p><strong>「格式：」</strong></p>
<p><code>ENV &lt;key&gt; &lt;value&gt;   # 假如你安装了JAVA程序，需要设置JAVA_HOME，那么可以在Dockerfile中这样写：   ENV JAVA_HOME /path/java/jdk   </code></p>
<ul>
<li><strong>「9. ADD」</strong></li>
</ul>
<p>从<strong>「src」</strong>复制文件到<strong>「container」</strong>的 <strong>「dest」</strong> 路径。主要用于将宿主机中的文件添加到镜像中。</p>
<p><strong>「格式：」</strong></p>
<p><code># &lt;src&gt; 是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件url; &lt;dest&gt; 是container中的绝对路径   ADD &lt;src&gt; &lt;dest&gt;   </code></p>
<ul>
<li><strong>「10. VOLUMN」</strong></li>
</ul>
<p>指定挂载点。使容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用， 也可以共享给其他容器使用。</p>
<p><strong>「格式：」</strong></p>
<p><code>VOLUME [&quot;&lt;mountpoint&gt;&quot;]   # 例：VOLUME [&quot;/tmp/data&quot;]   </code></p>
<p>运行通过该<strong>「Dockerfile」</strong>生成<strong>「image」</strong>的容器，<strong>「&#x2F;tmp&#x2F;data」</strong>目录中的数据在容器关闭后，里面的数据还存在。</p>
<ul>
<li><strong>「11. WORKDIR」</strong></li>
</ul>
<p>切换目录，可以多次切换(相当于<strong>「cd」</strong>命令)，对<strong>「RUN，CMD，ENTRYPOINT」</strong>生效。</p>
<p><strong>「格式：」</strong></p>
<p><code>WORKDIR /path/to/workdir   # 在/p1, /p2下执行vim a.txt   WORKDIR /p1 WORKDIR p2 RUN vim a.txt   </code></p>
<ul>
<li><strong>「12. ONBUILD」</strong></li>
</ul>
<p>在子镜像中执行</p>
<p><strong>「格式：」</strong></p>
<p><code># 指定的命令在构建镜像时并不执行，而是在它的子镜像中执行   ONBUILD &lt;Dockerfile关键字&gt;   </code></p>
<h5 id="2）「创建镜像」"><a href="#2）「创建镜像」" class="headerlink" title="2）「创建镜像」"></a>2）<strong>「创建镜像」</strong></h5><p>我们编辑好 <strong>「Dockerfile」</strong> 文件后，在 <strong>「Dockerfile」</strong> 所在目录输入指令：</p>
<p><code>docker build ‐t cbucImage:v1.0.0 ‐‐rm=true .   </code></p>
<p><strong>「注：」</strong></p>
<ul>
<li><strong>「‐t」</strong> 表示选择指定生成镜像的用户名，仓库名和tag</li>
<li><strong>「‐‐rm&#x3D;true」</strong> 表示指定在生成镜像过程中删除中间产生的临时容器。</li>
<li>上面构建命令中最后的 <strong>「.」</strong> 符号不要漏了，表示使用当前目录下的<strong>「Dockerfile」</strong>构建镜像</li>
</ul>
<h4 id="3-运行镜像"><a href="#3-运行镜像" class="headerlink" title="3. 运行镜像"></a>3. 运行镜像</h4><p>我们创建好镜像后，便可以使用以下指令运行：</p>
<p><code>docker run ‐itd ‐‐name centos1 ‐p 8888:80 cbucImage /bin/bash   </code></p>
<p>使用以下命令进入容器：</p>
<p><code>docker exec -it centos1 /bin/bash   </code></p>
<p><strong>「[END]」</strong></p>
]]></content>
  </entry>
  <entry>
    <title>eric汉化</title>
    <url>/2023/06/24/eric%E6%B1%89%E5%8C%96/</url>
    <content><![CDATA[<head>
  <meta charset="utf-8">
  <meta name="referrer" content="no-referrer" />
  <title>某eric汉化</title>
</head>

<body class="stackedit">
  <div class="stackedit__html"><p>网上的一堆教程真是够垃圾，复杂而又无效，明明是简单的事情，偏偏要搞得那么复杂。<br>
话不多说，简单技巧如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190608221440279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FoaGpoaGo=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>首先<br>
下载图片相关汉化包，<br>
其次<br>
放在其都是.qm的文件夹，如下图所示<br>
汉化成功!<br>
<br>
<img src="https://img-blog.csdnimg.cn/20201005223233514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FoaGpoaGo=,size_16,color_FFFFFF,t_70#pic_center" alt=""><img src="https://img-blog.csdnimg.cn/20190608221850982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FoaGpoaGo=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
附上成功界面<img src="https://img-blog.csdnimg.cn/20190608221935696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FoaGpoaGo=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</div>
</body>


]]></content>
  </entry>
  <entry>
    <title>Get请求如何正确的传递数组</title>
    <url>/2023/07/16/get-array/</url>
    <content><![CDATA[<h1 id="Get请求如何正确的传递数组"><a href="#Get请求如何正确的传递数组" class="headerlink" title="Get请求如何正确的传递数组"></a>Get请求如何正确的传递数组</h1><p>假如现在后端有这么一个接口&#x2F;users，前端可以通过传roleIds数组来查询这些角色关联的用户，后端的接口和参数定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Controller @GetMapping(&quot;/users&quot;) public R&lt;?&gt; list(ReqVo vo) &#123;   //... &#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ReqVo @Data public class ReqVo &#123;   private List&lt;String&gt; roleIds; &#125;</span></span><br></pre></td></tr></table></figure>
<p>那么我们可以有以下几种方式来传递数组：</p>
<ul>
<li>方式一</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">GET http://localhost:8080/users?roleIds=1&amp;roleIds=2</span><br></pre></td></tr></table></figure>
<ul>
<li>方式二</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET http://localhost:8080/users?roleIds=1,2</span><br></pre></td></tr></table></figure>
<ul>
<li>方式三</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET http://localhost:8080/users?roleIds[0]=1&amp;roleIds[1]=2</span><br></pre></td></tr></table></figure>
<ul>
<li>方式四</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">GET http://localhost:8080/users?roleIds[]=1&amp;roleIds[]=2</span><br></pre></td></tr></table></figure>
<p>需要注意的是，最后两种方式带有中括号<code>[]</code>，<code>[]</code>在url中属于功能性字符，前端需要使用<code>encodeURIComponent()</code>函数转义，否则在高版本tomcat中会出现_400 Bad Request_错误</p>
]]></content>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/2023/06/20/gitcomend/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>目的</th>
<th>GIT命令</th>
</tr>
</thead>
<tbody><tr>
<td>第一次初始化仓库</td>
<td><code>git init</code><br><code>git add .</code><br><code>git commit -m [描述字体，例如 &quot;first commit &quot;]</code><br><code>git remote add origin [仓库地址]</code><br><code>git push -u origin [分支名称，一般第一次有默认的master]</code></td>
</tr>
<tr>
<td>拉取远程分支到本地</td>
<td><code>git fetch origin [分支名称]</code></td>
</tr>
<tr>
<td>提送到git</td>
<td><code>git push origin [分支名称]</code></td>
</tr>
<tr>
<td>删除本地分支</td>
<td><code>git branch -d [分支的名称]</code></td>
</tr>
<tr>
<td>删除远程分支</td>
<td><code>git push origin --delete [分支的名称]</code></td>
</tr>
<tr>
<td>查看远程分支与本地分支</td>
<td><code>git branch -a</code></td>
</tr>
<tr>
<td>合并分支</td>
<td><code>git pull origin [目标分支]</code><br><code>git merge [被合分支]</code><br><code>git push origin [目标分支]</code></td>
</tr>
<tr>
<td>更新远程分支列表</td>
<td><code>git remote update origin --prune</code></td>
</tr>
<tr>
<td>查看所有分支</td>
<td><code>git branch -a</code></td>
</tr>
<tr>
<td>撤销提交</td>
<td><code>git reset --soft [HEAD^ | HEAD~1 | HEAD ~&lt;n&gt;]</code></td>
</tr>
<tr>
<td>创建本地分支</td>
<td><code>git branch [分支名称]</code></td>
</tr>
<tr>
<td>切换分支</td>
<td><code>git checkout [分支名称]</code></td>
</tr>
<tr>
<td>创建并切换到创建的分支</td>
<td><code>git checkout -b [分支名称]</code></td>
</tr>
<tr>
<td>根据已有的远程分支创建新的分支</td>
<td><code>git checkout -b [创建的分支名] origin/[远程的分支名称]</code></td>
</tr>
<tr>
<td>删除分支</td>
<td><code>git branch -d [分支名称]</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Git</category>
        <category>Git常用命令</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Git常用</tag>
      </tags>
  </entry>
  <entry>
    <title>lodash常用函数</title>
    <url>/2023/06/24/lodash/</url>
    <content><![CDATA[<p><a name="dOB5s"></a></p>
<h3 id="1-去虚函数"><a href="#1-去虚函数" class="headerlink" title="1.去虚函数"></a>1.去虚函数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">compact</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>, <span class="number">2</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">3</span>]);<span class="comment">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p><a name="FtVzU"></a></p>
<h3 id="2-分组"><a href="#2-分组" class="headerlink" title="2.分组"></a>2.分组</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">chunk</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], <span class="number">2</span>);<span class="comment">// =&gt; [[&#x27;a&#x27;, &#x27;b&#x27;], [&#x27;c&#x27;, &#x27;d&#x27;]]</span></span><br><span class="line"></span><br><span class="line">_.<span class="title function_">chunk</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], <span class="number">3</span>);</span><br><span class="line"><span class="comment">// =&gt; [[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], [&#x27;d&#x27;]]</span></span><br></pre></td></tr></table></figure>
<p><a name="v3C2P"></a></p>
<h3 id="3-连接"><a href="#3-连接" class="headerlink" title="3.连接"></a>3.连接</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> other = _.<span class="title function_">concat</span>(array, <span class="number">2</span>, [<span class="number">3</span>], [[<span class="number">4</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(other);</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3, [4]]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br><span class="line"><span class="comment">// =&gt; [1]</span></span><br></pre></td></tr></table></figure>
<p><a name="Kjn9J"></a></p>
<h3 id="4-限制字符串长度，超出用”…“表示"><a href="#4-限制字符串长度，超出用”…“表示" class="headerlink" title="4.限制字符串长度，超出用”…“表示"></a>4.限制字符串长度，超出用”…“表示</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="string">&quot;aaaadfdfdfdf&quot;</span></span><br><span class="line"><span class="keyword">let</span> b=<span class="title function_">truncate</span>(a,&#123;<span class="attr">length</span>:(<span class="number">8</span>+<span class="number">3</span>)&#125;) <span class="comment">// 默认为&quot;...&quot;,加3是因为三个点也包括在里面</span></span><br><span class="line"><span class="keyword">let</span> b=<span class="title function_">truncate</span>(a,&#123;<span class="attr">length</span>:(<span class="number">8</span>+<span class="number">3</span>),<span class="attr">omission</span>: <span class="string">&#x27;&gt;&gt;&gt;&#x27;</span>&#125;) <span class="comment">// </span></span><br></pre></td></tr></table></figure>
<p><a name="SMd0x"></a></p>
<h3 id="5-数组相减"><a href="#5-数组相减" class="headerlink" title="5.数组相减"></a>5.数组相减</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result=_.<span class="title function_">difference</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])   <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>
<p><a name="G2KFy"></a></p>
<h3 id="工作实际用到过"><a href="#工作实际用到过" class="headerlink" title="工作实际用到过"></a>工作实际用到过</h3><p><a name="QmMQ2"></a></p>
<h4 id="1-map与pick-x2F-omit的结合"><a href="#1-map与pick-x2F-omit的结合" class="headerlink" title="1.map与pick&#x2F;omit的结合"></a>1.map与pick&#x2F;omit的结合</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;map, pick, omit&#125; <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span></span><br><span class="line"><span class="comment">// 提取Name与Num</span></span><br><span class="line"><span class="keyword">let</span> interData = <span class="title function_">map</span>(takeCreateData, <span class="function"><span class="params">o</span> =&gt;</span> <span class="title function_">pick</span>(o, [<span class="string">&#x27;Name&#x27;</span>, <span class="string">&quot;Num&quot;</span>]))</span><br><span class="line"><span class="comment">// 剔除Name与Num</span></span><br><span class="line"><span class="keyword">let</span> outterData = <span class="title function_">map</span>(takeCreateData, <span class="function"><span class="params">o</span> =&gt;</span> <span class="title function_">omit</span>(o, [<span class="string">&#x27;Name&#x27;</span>, <span class="string">&quot;Num&quot;</span>]))</span><br></pre></td></tr></table></figure>
<p><a name="lcXvK"></a></p>
<h4 id="2-去重-isEqual-uniqWith，uniq"><a href="#2-去重-isEqual-uniqWith，uniq" class="headerlink" title="2.去重 isEqual, uniqWith，uniq"></a>2.去重 isEqual, uniqWith，uniq</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;unip, uniqWith, isEqual&#125; <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span></span><br><span class="line"><span class="comment">// 纯数组 例如[1,1,2,3,4,4,5]</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="title function_">uniq</span>(arr) <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"><span class="comment">// 对象数组 例如 [&#123;a:1,b:2&#125;,&#123;a:1,b:2&#125;,&#123;a:1,b:3&#125;] </span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title function_">uniqWith</span>(arr_, isEqual) <span class="comment">// [&#123;a:1,b:2&#125;,&#123;a:1,b:3&#125;]</span></span><br></pre></td></tr></table></figure>
<p><a name="Ue52a"></a></p>
<h4 id="3-排序orderby"><a href="#3-排序orderby" class="headerlink" title="3.排序orderby"></a>3.排序orderby</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; orderBy &#125; <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span></span><br><span class="line"><span class="comment">/** 根据对象数组里面某个键的值来重新排序，desc 降序,asc升序,</span></span><br><span class="line"><span class="comment"> ** 例如[&#123;a:1,b:2&#125;,&#123;a:2,b:3&#125;]   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">targetData = <span class="title function_">orderBy</span>(targetData, [<span class="string">&quot;a&quot;</span>], [<span class="string">&quot;desc&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串排序</span></span><br><span class="line"><span class="title function_">sortBy</span>(value,[<span class="keyword">function</span>(<span class="params">o</span>) &#123; <span class="keyword">return</span> o; &#125;]);</span><br></pre></td></tr></table></figure>
<p><a name="u25Pt"></a></p>
<h4 id="4-数组相减，lodash-没有找到的，有替代方法，待找"><a href="#4-数组相减，lodash-没有找到的，有替代方法，待找" class="headerlink" title="4.数组相减，lodash 没有找到的，有替代方法，待找"></a>4.数组相减，lodash 没有找到的，有替代方法，待找</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> ids=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> unids = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">// let needids = ids.filter(el =&gt; !unids.includes(el)) //[1,2,3]</span></span><br><span class="line"><span class="keyword">let</span> needids = ids.<span class="title function_">filter</span>(<span class="function"><span class="params">el</span> =&gt;</span> !pids.<span class="title function_">find</span>(<span class="function"><span class="params">pid</span> =&gt;</span> pid === el))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>lodash</tag>
        <tag>常用</tag>
      </tags>
  </entry>
  <entry>
    <title>设置VsCode</title>
    <url>/2023/07/26/settingvscode/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ol>
<li>组合键：ctrl +shift + p，然后搜Open Raw Default Settings，回车就可打开这个默认设置文件。</li>
</ol>
<h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><ol start="2">
<li>如果想把设置里的内容更新到默认设置里面，打开设置：ctrl +shift + p，搜setting，在里面加入这一行：“<a href="https://so.csdn.net/so/search?q=workbench&spm=1001.2101.3001.7020">workbench</a>.settings.useSplitJSON”: true,，然后重启vscode</li>
</ol>
<p>原文链接 ：<a href="https://blog.csdn.net/zsc201825/article/details/90740971">https://blog.csdn.net/zsc201825/article/details/90740971</a></p>
]]></content>
  </entry>
  <entry>
    <title>npm发布包</title>
    <url>/2023/07/26/summitnpm/</url>
    <content><![CDATA[<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><ol>
<li>第一次发布包<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm publish </span><br></pre></td></tr></table></figure></li>
<li>第二次发布包<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm version patch</span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>unicloud 常用查表</title>
    <url>/2023/06/24/unicloud%20%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%A1%A8/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接关联多个表为虚拟联表再进行查询，旧写法，目前更推荐使用getTemp进行联表查询</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> db.<span class="title function_">collection</span>(<span class="string">&#x27;order,book&#x27;</span>).<span class="title function_">where</span>(<span class="string">&#x27;_id==&quot;1&quot;&#x27;</span>).<span class="title function_">get</span>() <span class="comment">// 直接关联order和book之后再过滤</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用getTemp先过滤处理获取临时表再联表查询，推荐用法</span></span><br><span class="line"><span class="keyword">const</span> order = db.<span class="title function_">collection</span>(<span class="string">&#x27;order&#x27;</span>).<span class="title function_">where</span>(<span class="string">&#x27;_id==&quot;1&quot;&#x27;</span>).<span class="title function_">getTemp</span>() <span class="comment">// 注意结尾的方法是getTemp，对order表过滤得到临时表</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> db.<span class="title function_">collection</span>(order, <span class="string">&#x27;book&#x27;</span>).<span class="title function_">get</span>() <span class="comment">// 将获取的order表的临时表和book表进行联表查询</span></span><br><span class="line"></span><br><span class="line">第二种比较好</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端联表查询</span></span><br><span class="line"><span class="keyword">const</span> db = uniCloud.<span class="title function_">database</span>()</span><br><span class="line"><span class="keyword">const</span> order = db.<span class="title function_">collection</span>(<span class="string">&#x27;order&#x27;</span>).<span class="title function_">field</span>(<span class="string">&#x27;book_id,quantity&#x27;</span>).<span class="title function_">getTemp</span>() <span class="comment">// 临时表field方法内需要包含关联字段，否则无法建立关联关系</span></span><br><span class="line"><span class="keyword">const</span> book = db.<span class="title function_">collection</span>(<span class="string">&#x27;book&#x27;</span>).<span class="title function_">field</span>(<span class="string">&#x27;_id,title,author&#x27;</span>).<span class="title function_">getTemp</span>() <span class="comment">// 临时表field方法内需要包含关联字段，否则无法建立关联关系</span></span><br><span class="line">db.<span class="title function_">collection</span>(order, book) <span class="comment">// 注意collection方法内需要传入所有用到的表名，用逗号分隔，主表需要放在第一位</span></span><br><span class="line">  .<span class="title function_">where</span>(<span class="string">&#x27;book_id.title == &quot;三国演义&quot;&#x27;</span>) <span class="comment">// 查询order表内书名为“三国演义”的订单</span></span><br><span class="line">  .<span class="title function_">get</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用虚拟联表查询</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> db.<span class="title function_">collection</span>(<span class="string">&#x27;article,comment&#x27;</span>)</span><br><span class="line">.<span class="title function_">where</span>(<span class="string">&#x27;article_id._value==&quot;1&quot;&#x27;</span>)</span><br><span class="line">.<span class="title function_">get</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先过滤article表，再获取虚拟联表联表获取评论</span></span><br><span class="line"><span class="keyword">const</span> article = db.<span class="title function_">collection</span>(<span class="string">&#x27;article&#x27;</span>).<span class="title function_">where</span>(<span class="string">&#x27;article_id==&quot;1&quot;&#x27;</span>).<span class="title function_">getTemp</span>() <span class="comment">// 注意是getTemp不是get</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> db.<span class="title function_">collection</span>(article, <span class="string">&#x27;comment&#x27;</span>).<span class="title function_">get</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> db = uniCloud.<span class="title function_">database</span>()</span><br><span class="line">db.<span class="title function_">collection</span>(<span class="string">&#x27;book&#x27;</span>)</span><br><span class="line">  .<span class="title function_">where</span>(<span class="string">&#x27;status == &quot;onsale&quot;&#x27;</span>)</span><br><span class="line">  .<span class="title function_">skip</span>(<span class="number">20</span>) <span class="comment">// 跳过前20条</span></span><br><span class="line">  .<span class="title function_">limit</span>(<span class="number">20</span>) <span class="comment">// 获取20条</span></span><br><span class="line">  .<span class="title function_">get</span>()</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 上述用法对应的分页条件为：每页20条取第2页</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.<span class="title function_">collection</span>(<span class="string">&#x27;order&#x27;</span>).<span class="title function_">count</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = uniCloud.<span class="title function_">database</span>()</span><br><span class="line">  db.<span class="title function_">collection</span>(<span class="string">&#x27;order&#x27;</span>)</span><br><span class="line">    .<span class="title function_">get</span>(&#123;</span><br><span class="line">      <span class="attr">getCount</span>:<span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bannerQuery = db.<span class="title function_">collection</span>(<span class="string">&#x27;banner&#x27;</span>).<span class="title function_">field</span>(<span class="string">&#x27;url,image&#x27;</span>).<span class="title function_">getTemp</span>() <span class="comment">// 这里使用getTemp不直接发送get请求，等到multiSend时再发送</span></span><br><span class="line"><span class="keyword">const</span> noticeQuery = db.<span class="title function_">collection</span>(<span class="string">&#x27;notice&#x27;</span>).<span class="title function_">field</span>(<span class="string">&#x27;text,url,level&#x27;</span>).<span class="title function_">getTemp</span>()</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> db.<span class="title function_">multiSend</span>(bannerQuery,noticeQuery)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>unicloud</tag>
        <tag>常用查表</tag>
      </tags>
  </entry>
  <entry>
    <title>博客应用其他地方图片403问题</title>
    <url>/2023/06/24/%E5%8D%9A%E5%AE%A2%E5%BA%94%E7%94%A8%E5%85%B6%E4%BB%96%E5%9C%B0%E6%96%B9%E5%9B%BE%E7%89%87404%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="解决hexo博客不能显示图床图片问题"><a href="#解决hexo博客不能显示图床图片问题" class="headerlink" title="解决hexo博客不能显示图床图片问题"></a><a href="https://www.cnblogs.com/yangstar/articles/16688692.html">解决hexo博客不能显示图床图片问题</a></h1><p>刚搭建好了hexo博客，写了一篇带图的文章，结果发现图挂了…之前看博客扫到hexo博客显示本地图片可能会有问题，于是选了图床图片的方式插图，结果还是没能幸免，好在搜索了半天，解决了这个问题，这里做个记录，帮助后面遇到问题的同学。</p>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><h3 id="问题情境："><a href="#问题情境：" class="headerlink" title="问题情境："></a>问题情境：</h3><p>在自己电脑的Chrome浏览器查看博客，正常显示图片，切换到Safari、火狐浏览器图片挂了。 手机端各浏览器均显示不了图片。</p>
<h3 id="解决步骤："><a href="#解决步骤：" class="headerlink" title="解决步骤："></a>解决步骤：</h3><ul>
<li>分析</li>
</ul>
<ol>
<li><p>检查图床图片的链接：</p>
<p>点进去发现图片正常显示，排除图床服务器问题。</p>
</li>
<li><p>用Chrome打开博文，右键检查或者查看网页源码：</p>
<p>找到图床图片链接，点击发生403(Forbidden)错误，找到问题根源。</p>
</li>
</ol>
<ul>
<li><p>解决</p>
<p>403 forbidden，说明了这个网络资源这样获取是被拒绝的，那么通过简单的谷歌，找到了相关的解决方法，并去实际尝试：</p>
<p>解决方法 ：只需要在markdown文章开头添加一个<code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code></p>
<p>然后就是<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>上传博客了，这一次分别在电脑和手机端打开文章，图片显示正常，问题解决。</p>
</li>
</ul>
<h2 id="原理解析："><a href="#原理解析：" class="headerlink" title="原理解析："></a>原理解析：</h2><p>为了不做一个只会搬运的码农，这里简单讲解一下原理：</p>
<ol>
<li>HTML的 标签提供了 HTML 文档的元数据。元数据不会显示在客户端，但是会被浏览器解析。这也是为什么加在mardown文章里不会看到这段代码的原因。</li>
<li>HTML 的 name 属性规定了元数据的名称，这里我们用到的是referer属性，这个属性的作用是让服务器判断来源页面，即用户是从哪来的，很多时候referer被当做防盗链来使用，服务器根据你的访问来源判断是否应该让你下载这个资源，如果你的来源不和规范，比如是个恶意爬虫，那么就会产生403错误。</li>
<li>到这里，<code>content=&quot;no-referrer&quot;</code>的意义就呼之欲出了，既然我们想拿到这个资源但被服务器认出来之后又被拒绝了，那么伪装一下，不告诉服务器不就行了？所以，这里content的no-referer就是表示不发送引用数据，隐藏自己的来源信息。这样，图片就能正常显示了。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://newsn.net/say/referer-policy.html">https://newsn.net/say/referer-policy.html</a></li>
<li><a href="https://www.cnblogs.com/selier/p/9570650.html">https://www.cnblogs.com/selier/p/9570650.html</a></li>
</ul>
]]></content>
      <tags>
        <tag>常识</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>批量改文件名与爬虫</title>
    <url>/2023/06/24/%E6%89%B9%E9%87%8F%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%8E%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
批量该文件名：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">path = input(&#x27;请输入文件路径(结尾加上/)：&#x27;)</span><br><span class="line"></span><br><span class="line"># 获取该目录下所有文件，存入列表中</span><br><span class="line">fileList = os.listdir(path)</span><br><span class="line"></span><br><span class="line">n = 0</span><br><span class="line">for i in fileList:</span><br><span class="line">    # 设置旧文件名（就是路径+文件名）</span><br><span class="line">    oldname = path + os.sep + fileList[n]  # os.sep添加系统分隔符</span><br><span class="line"></span><br><span class="line">    # 设置新文件名</span><br><span class="line">    newname = path  + os.sep + &#x27;ZhaoLiying&#x27; + str(n + 1) + &#x27;.JPG&#x27;</span><br><span class="line"></span><br><span class="line">    os.rename(oldname, newname)  # 用os模块中的rename方法对文件改名</span><br><span class="line">    print(oldname, &#x27;======&gt;&#x27;, newname)</span><br><span class="line"></span><br><span class="line">    n += 1</span><br></pre></td></tr></table></figure>
爬虫：

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import urllib.request as ur</span><br><span class="line">import os</span><br><span class="line">import string</span><br><span class="line">import threading</span><br><span class="line">import re</span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_image(keyworld, pn, rn, type, i):</span><br><span class="line">    try:</span><br><span class="line">        url = ur.quote(</span><br><span class="line">            &#x27;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&#x27;</span><br><span class="line">            &#x27;&amp;queryWord=&#x27; + keyworld + &#x27;&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=-1&amp;z=&amp;ic=0&amp;word=&#x27; + keyworld +</span><br><span class="line">            &#x27;&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;qc=&amp;nc=1&amp;fr=&amp;pn=&#x27; + str(pn) + &#x27;&amp;rn=&#x27; + str(</span><br><span class="line">                rn) + &#x27;&amp;gsm=1e&amp;1529504588260=&#x27;,</span><br><span class="line">            safe=string.printable)</span><br><span class="line">        req = ur.Request(url)</span><br><span class="line">        req.add_header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0&quot;)</span><br><span class="line">        html1 = ur.urlopen(url, timeout=600).read()</span><br><span class="line">        html1 = str(html1)</span><br><span class="line"></span><br><span class="line">        pat1 = &#x27;&quot;thumbURL&quot;:&quot;.+?&quot;,&#x27;</span><br><span class="line">        pat2 = &#x27;https:.+?.jpg&#x27;</span><br><span class="line">        thumbURLs = re.compile(pat1).findall(html1)</span><br><span class="line">        imageURLs = re.compile(pat2).findall(str(thumbURLs))</span><br><span class="line"></span><br><span class="line">        save_dir = type + &#x27;/&#x27; + type + i + &#x27;/&#x27;</span><br><span class="line">        if os.path.exists(save_dir) is False:</span><br><span class="line">            os.makedirs(save_dir)</span><br><span class="line">        num = 1</span><br><span class="line">        for index, imageurl in enumerate(imageURLs):</span><br><span class="line">            try:</span><br><span class="line">                data = ur.urlopen(imageurl, timeout=20).read()</span><br><span class="line">                fd = open(save_dir + type + &#x27;_&#x27; + str(pn) + &#x27;_&#x27; + str(index) + &#x27;.jpg&#x27;, &quot;wb&quot;)</span><br><span class="line">                fd.write(data)</span><br><span class="line">                fd.close()</span><br><span class="line">                sys.stdout.write(&#x27;下载成功%s\r&#x27; % num)</span><br><span class="line">                sys.stdout.flush()</span><br><span class="line">                num = num + 1</span><br><span class="line">            except Exception as e:</span><br><span class="line">                print(&#x27;保存图片异常:&#x27; + e)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&#x27;获取图片url异常:&#x27; + e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    ai = input(&quot;Input key: &quot;)</span><br><span class="line">    bi = input(&quot;Input num: &quot;)</span><br><span class="line">    for i in range(int(bi)):</span><br><span class="line">        get_image(ai, i * 50, 50, ai, str(i))</span><br><span class="line">    # tA = ThreadA()</span><br><span class="line">    # tA.start()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>开源中国charm插件安装</title>
    <url>/2023/06/24/%E5%BC%80%E6%BA%90%E4%B8%AD%E5%9B%BD%EF%BD%83%EF%BD%88%EF%BD%81%EF%BD%92%EF%BD%8D%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="referrer" content="no-referrer" />
  <title>开源中国ｃｈａｒｍ插件安装</title>
  <!-- <link rel="stylesheet" href="https://stackedit.io/style.css" /> -->
</head>

<body class="stackedit">
  <div class="stackedit__html"><h4><a id="_0"></a>开源中国Ｃｈｒｏｍｅ插件的安装</h4>
<p>早上亲自在ｃｈａｒｍ中安装开源中国，没想到浪费的很多时间，出错如下：<br>
我在网上找到的开源中国的插件ｃｒｘ，点击https://gitee.com/jaywcjlove/oscnews/releases<br>
就可以访问这个页面<br>
<img src="https://img-blog.csdnimg.cn/20190714135225199.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FoaGpoaGo=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
向下滑就找到ｏｓｃｎｅｗｓ－ｖ１．１０．０．ｃｒｘ就自动下载，会出现以下画面：<br>
<img src="https://img-blog.csdnimg.cn/20190714135437250." alt="在这里插入图片描述">，然后就出错了<br>
<img src="https://img-blog.csdnimg.cn/20190714135505948." alt="在这里插入图片描述"><br>
想把它单独下载出来去不可以，所以我想到另外一个办法，在其他浏览器打开，就可以下载了，比如ＱＱ浏览器，出现以下画面：<br>
<img src="https://img-blog.csdnimg.cn/20190714140108599." alt="在这里插入图片描述"><br>
就可以下载，但是还不可以用，要把下载的文件后缀名改为．ｒａｒ，解压，把解压的第一个文件夹名字“＿ｍｘｘ”改为“ｍｘｘ””，如下图<br>
<img src="https://img-blog.csdnimg.cn/2019071414053167.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FoaGpoaGo=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
在浏览器打开chrome://extensions/，点击添加已解压文件，<br>
<img src="https://img-blog.csdnimg.cn/20190714140959455.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FoaGpoaGo=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">附属一个成功图片<br>
<img src="https://img-blog.csdnimg.cn/20190714141052211.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FoaGpoaGo=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
如果实在下载不了的话，我分享给你，有两个版本，链接如下：链接：https://pan.baidu.com/s/1gdziACgg6b2jTTkPg9K4gg<br>
密码欢迎评论区评论，或者去我上传的资源找<br>
创造不易,感谢赞赏<br>
<img src="https://img-blog.csdnimg.cn/20190726144701656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FoaGpoaGo=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</div>
</body>

</html>
]]></content>
      <categories>
        <category>插件</category>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>开源中国</tag>
        <tag>charm插件</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器全局代理clash</title>
    <url>/2023/08/22/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86clash/</url>
    <content><![CDATA[<h1 id="目的介绍"><a href="#目的介绍" class="headerlink" title="目的介绍"></a>目的介绍</h1><p>主要是为了解决我们在服务器上下载GitHub等一些国外资源速度慢的问题。</p>
<h1 id="使用须知"><a href="#使用须知" class="headerlink" title="使用须知"></a>使用须知</h1><ul>
<li>运行本项目建议使用root用户，或者使用 sudo 提权。</li>
<li>使用过程中如遇到问题，请查看开源项目 <a href="https://github.com/wanhebin/clash-for-linux.git">https://github.com/wanhebin/clash-for-linux.git</a></li>
<li>本项目是基于 <a href="https://github.com/Dreamacro/clash">clash</a> 、<a href="https://github.com/haishanh/yacd">yacd</a> 进行的配置整合，关于clash、yacd的详细配置请去原项目查看。</li>
<li>此项目不提供任何订阅信息，请自行准备Clash订阅地址。</li>
<li>运行前请手动更改<code>.env</code>文件中的<code>CLASH_URL</code>变量值，否则无法正常运行。</li>
<li>当前在RHEL系列和Debian系列Linux系统中测试过，其他系列可能需要适当修改脚本。</li>
<li>支持 x86_64&#x2F;aarch64 平台</li>
</ul>
<h1 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h1><h2 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h2><p>下载项目</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/wanhebin/clash-for-linux.git</span><br></pre></td></tr></table></figure>

<p>进入到项目目录，编辑<code>.env</code>文件，修改变量<code>CLASH_URL</code>的值。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> clash-for-linux</span><br><span class="line">$ vim .<span class="built_in">env</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong> <code>.env</code> 文件中的变量 <code>CLASH_SECRET</code> 为自定义 Clash Secret，值为空时，脚本将自动生成随机字符串。</p>
</blockquote>
<h2 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h2><p>直接运行脚本文件<code>start.sh</code></p>
<ul>
<li>进入项目目录</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> clash-for-linux</span><br></pre></td></tr></table></figure>

<ul>
<li>运行启动脚本</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">proxy_offSecret$ sudo bash start.sh</span><br><span class="line"></span><br><span class="line">正在检测订阅地址...</span><br><span class="line">Clash订阅地址可访问！                                      [  OK  ]</span><br><span class="line"></span><br><span class="line">正在下载Clash配置文件...</span><br><span class="line">配置文件config.yaml下载成功！                              [  OK  ]</span><br><span class="line"></span><br><span class="line">正在启动Clash服务...</span><br><span class="line">服务启动成功！                                             [  OK  ]</span><br><span class="line"></span><br><span class="line">Clash Dashboard 访问地址：http://&lt;ip&gt;:9090/ui</span><br><span class="line">Secret：xxxxxxxxxxxxx</span><br><span class="line"></span><br><span class="line">请执行以下命令加载环境变量: <span class="built_in">source</span> /etc/profile.d/clash.sh</span><br><span class="line"></span><br><span class="line">请执行以下命令开启系统代理: proxy_on</span><br><span class="line"></span><br><span class="line">若要临时关闭系统代理，请执行: proxy_off</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> /etc/profile.d/clash.sh</span><br><span class="line">$ proxy_on</span><br></pre></td></tr></table></figure>

<ul>
<li>检查服务端口</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ netstat -tln | grep -E <span class="string">&#x27;9090|789.&#x27;</span></span><br><span class="line">tcp        0      0 127.0.0.1:9090          0.0.0.0:*               LISTEN     </span><br><span class="line">tcp6       0      0 :::7890                 :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 :::7891                 :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 :::7892                 :::*                    LISTEN</span><br></pre></td></tr></table></figure>

<ul>
<li>检查环境变量</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">env</span> | grep -E <span class="string">&#x27;http_proxy|https_proxy&#x27;</span></span><br><span class="line">http_proxy=http://127.0.0.1:7890</span><br><span class="line">https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>

<p>以上步鄹如果正常，说明服务clash程序启动成功，现在就可以体验高速下载github资源了。</p>
<blockquote>
<p>注意：**</p>
<ol>
<li>Secret值记得提前保存下来，不然待会可能会很狼狈地在执行一次命令。</li>
<li>代理只要没proxy_off就不会停。但是此时仅仅代理了当前的“cmd”，“cmd”重新打开代理会生效，可以考虑全局代理，就没有该烦恼</li>
</ol>
</blockquote>
<h2 id="重启程序"><a href="#重启程序" class="headerlink" title="重启程序"></a>重启程序</h2><p>如果需要对Clash配置进行修改，请修改 <code>conf/config.yaml</code> 文件。然后运行 <code>restart.sh</code> 脚本进行重启。</p>
<blockquote>
<p><strong>注意：</strong><br>重启脚本 <code>restart.sh</code> 不会更新订阅信息。</p>
</blockquote>
<h2 id="停止程序"><a href="#停止程序" class="headerlink" title="停止程序"></a>停止程序</h2><ul>
<li>进入项目目录</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> clash-for-linux</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭服务</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo bash shutdown.sh</span><br><span class="line"></span><br><span class="line">服务关闭成功，请执行以下命令关闭系统代理：proxy_off</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ proxy_off</span><br></pre></td></tr></table></figure>

<p>然后检查程序端口、进程以及环境变量<code>http_proxy|https_proxy</code>，若都没则说明服务正常关闭。</p>
<h2 id="Clash-Dashboard"><a href="#Clash-Dashboard" class="headerlink" title="Clash Dashboard"></a>Clash Dashboard</h2><ul>
<li>访问 Clash Dashboard</li>
</ul>
<p><del>通过浏览器访问 <code>start.sh</code> 执行成功后输出的地址，例如：<a href="http://192.168.0.1:9090/ui">http://192.168.0.1:9090/ui</a></del></p>
<p><del>此 Clash Dashboard 使用的是<a href="https://github.com/haishanh/yacd">yacd</a>项目，详细使用方法请移步到yacd上查询。</del></p>
<p>通过浏览器访问别人部署好的网站，<a href="http://clash.razord.top/#/proxies">http://clash.razord.top/#/proxies</a>  </p>
<ul>
<li>登录管理界面</li>
</ul>
<p>在<code>API Base URL</code>一栏中输入：http:&#x2F;&#x2F;&lt;ip&gt;:9090 ，在<code>Secret(optional)</code>一栏中输入启动成功后输出的Secret。</p>
<p>点击Add并选择刚刚输入的管理界面地址，之后便可在浏览器上进行一些配置。</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ol>
<li><p>部分Linux系统默认的 shell <code>/bin/sh</code> 被更改为 <code>dash</code>，运行脚本会出现报错（报错内容一般会有 <code>-en [ OK ]</code>）。建议使用 <code>bash xxx.sh</code> 运行脚本。</p>
</li>
<li><p>部分用户在UI界面找不到代理节点，基本上是因为厂商提供的clash配置文件是经过base64编码的，且配置文件格式不符合clash配置标准。</p>
<p>目前此项目已集成自动识别和转换clash配置文件的功能。如果依然无法使用，则需要通过自建或者第三方平台（不推荐，有泄露风险）对订阅地址转换。</p>
</li>
<li><p>程序日志中出现<code>error: unsupported rule type RULE-SET</code>报错，解决方法查看官方<a href="https://github.com/Dreamacro/clash/wiki/FAQ#error-unsupported-rule-type-rule-set">WIKI</a></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>输出文件目录</title>
    <url>/2023/08/22/%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95(2023811)/</url>
    <content><![CDATA[<h2 id="输出文件目录"><a href="#输出文件目录" class="headerlink" title="输出文件目录"></a>输出文件目录</h2><blockquote>
<p>tree 命令</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/F 显示每个文件夹中文件的名称。</span><br><span class="line"></span><br><span class="line">/A 使用 ASCII 字符，而不使用扩展字符(会把当前目录下的结构给展出来)。</span><br><span class="line"></span><br><span class="line">TREE [drive:][path] [/F] [/A]</span><br><span class="line">tree D:\目录树.txt        \\ 保存目录树到D盘下  </span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
